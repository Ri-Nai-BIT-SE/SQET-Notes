# 等价类划分法（Equivalence Partitioning）

## 概念理解

因为输入数据是无穷的，不可能穷举（比如测试加法，不能把世界上所有数字都加一遍）。所以我们将输入域划分为若干个"等价类"。

*   **假设**：在同一个等价类中，任何一个数据的测试效果是相同的。测了一个，就等于测了这一类。

## 划分标准（填表关键）

考试时通常需要画一个表，包含以下两类：

1.  **有效等价类**：符合程序规格说明书要求的、合理的输入数据。
    *   *目的*：验证程序"做了该做的事"。
2.  **无效等价类**：不符合规定的、不合理的输入数据。
    *   *目的*：验证程序"没做不该做的事"（即容错性）。

## 📝 考试答题套路（必背！）

如果题目让你"用等价类划分法设计测试用例"，必须严格遵循以下步骤，否则扣分：

**第一步：列出等价类表**

| 输入条件 | 有效等价类 (编号) | 无效等价类 (编号) |
| :--- | :--- | :--- |
| 比如：年龄(1-100) | 1~100之间 (1) | < 1 (2) |
| | | > 100 (3) |
| | | 非数字字符 (4) |

**第二步：设计测试用例（覆盖原则 - 这是一个巨大的坑！）**

*   **原则 A（针对有效类）**：设计一个新的测试用例，使其**尽可能多地**覆盖尚未被覆盖的**有效**等价类。
    *   *理由*：为了效率，正常的流程能合在一起测就合在一起。
*   **原则 B（针对无效类）**：设计一个新的测试用例，使其**仅**覆盖**一个**尚未被覆盖的**无效**等价类。
    *   *理由*：为了避免"错误屏蔽"。如果一个用例同时包含两个错误输入（比如年龄-5岁 且 身高3米），程序可能在检查到年龄错误后就报错退出了，导致身高的错误检查逻辑根本没跑到。

## 设计步骤

1. 确定等价类（有效/无效）
2. 建立等价类表（必须编号）
3. 设计测试用例
   - 有效类：尽可能多覆盖（合并测试）
   - 无效类：每次只覆盖一个（避免错误屏蔽）

---

## 🎯 实战演练：Pascal标识符设计（完整示例）

这是等价类划分法在考试或实际工作中的标准操作流程。

### 需求原文

> "标识符是由字母开头，后跟字母或数字的任意组合构成。编译器能够区分的有效字符数为8个，最大字符数为80个。"

### 第一步：分析输入条件

把需求拆解成独立的校验维度：

1. **首字符规则**：必须是字母
2. **后续字符规则**：必须是字母或数字
3. **长度规则**：1到80个字符（注：虽然有效识别是8个，但允许输入到80个，所以输入限制是1-80）

### 第二步：建立等价类表（核心步骤）

按照标准格式，列出**有效等价类**和**无效等价类**，并给它们**编号**。

| 输入条件 | 有效等价类 (编号) | 无效等价类 (编号) |
| :--- | :--- | :--- |
| **1. 首字符** | 字母 (1) | 数字 (4) <br> 特殊字符 (5) |
| **2. 后续字符** | 字母或数字 (2) | 特殊字符 (6) |
| **3. 长度** | 1 到 80 个字符 (3) | 0 个字符 (7) <br> >80 个字符 (8) |

**注意**：为什么要把无效等价类拆这么细？因为"以数字开头"和"以#开头"报错提示可能不同，需要分别测试。

### 第三步：设计测试用例（覆盖原则）

#### 原则一：覆盖有效等价类

**目标**：用**最少**的用例，把表里所有**有效等价类(1, 2, 3)**全部覆盖完。

**设计用例 1**：
- **输入数据**：`Max1`
- **覆盖编号**：(1) 首字符是字母、(2) 后续是字母数字、(3) 长度为4（在1-80之间）
- **预期结果**：有效
- **说明**：这一个用例就把所有有效等价类都覆盖了

#### 原则二：覆盖无效等价类（特别强调）

**目标**：设计新用例，**每次只覆盖一个**尚未覆盖的无效编号。

**核心逻辑**：**不能试图用一个"五毒俱全"的用例来测试所有错误**。

**错误示范**：输入 `1Var#` （既以数字开头，又有特殊字符）
- **为什么错？** 程序可能检测到"数字开头"就直接报错退出了，导致"特殊字符检查"的代码根本没运行到。这叫**错误屏蔽**。

**正确设计**：

**用例 2（测编号4）**：
- **输入数据**：`5Two`
- **覆盖编号**：(4) —— 首字符是数字
- **预期结果**：无效（报错：必须以字母开头）

**用例 3（测编号5）**：
- **输入数据**：`$Tree`
- **覆盖编号**：(5) —— 首字符是特殊字符
- **预期结果**：无效

**用例 4（测编号6）**：
- **输入数据**：`Var#`
- **覆盖编号**：(6) —— 后续字符含特殊符号
- **注意**：首字符必须正确（V），长度必须正确，只有"后续字符"这一个条件是错的
- **预期结果**：无效

**用例 5（测编号7）**：
- **输入数据**：` ` (空字符串)
- **覆盖编号**：(7) —— 长度为0
- **预期结果**：无效

**用例 6（测编号8）**：
- **输入数据**：`A...A(81个A)`
- **覆盖编号**：(8) —— 长度>80
- **预期结果**：无效

### 完整测试用例表（满分答卷格式）

| ID | 输入数据 | 预期结果 | 覆盖的等价类编号 |
| :--- | :--- | :--- | :--- |
| TC1 | Max1 | 有效 | 1, 2, 3 |
| TC2 | 5Two | 无效 | 4 |
| TC3 | $Tree | 无效 | 5 |
| TC4 | Var# | 无效 | 6 |
| TC5 | [空] | 无效 | 7 |
| TC6 | A...A(81个) | 无效 | 8 |

---

## 深度解析：等价类划分的"潜规则"

### 1. 区间的划分

**规则**：如果规定了取值范围（如 1~999），无效等价类必须是**两个**。

**详解**：你不能笼统地说"不在范围内"，必须拆分为 **<1** 和 **>999**。因为程序处理"负数"和处理"溢出"的逻辑往往不同。

**示例**：
| 输入条件 | 有效等价类 | 无效等价类 |
|---------|-----------|-----------|
| 年龄(1-999) | 1~999之间 | < 1 <br> > 999 |

### 2. 集合的划分

**规则**：如果规定了必须属于某个集合（如：输入必须是红色、黄色、蓝色）。

**详解**：
- **有效等价类**：红色、黄色、蓝色（各算一个，或者归为一个"有效颜色类"）
- **无效等价类**：**非**集合内的值（如：绿色）

### 3. 布尔值的划分

**规则**：如果是是非题。

**详解**：
- **有效**：真
- **无效**：假
- **注意**：别忘了可能有"非真非假"的异常输入（如输入了null）

> **来源文件**：`output_4_12_3.txt`，`output_4_13_1.txt`
